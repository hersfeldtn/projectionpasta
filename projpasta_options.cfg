#Some notes:
# lines starting with # are comments, [ are section heads, others are actual options
# Each option has an associated explanation
# Extra options can be added or existing options can be removed and neither should break the script
# Sections are unimportant, they're just here for organization
# Values will be interpreted like so:
#  integers if they contain only numbers and/or a minus sign (-)
#  floats if they also have a decimal point (.)
#  strings if they contain other characters, except for a few special cases:
#   None if they read none, None, or None
#   boolean True if they read true, True, or TRUE
#   boolean False if they read false, False, or FALSE
#	if they contain ( or , will attempt to read as a tuple, will read as string if this fails

[Output_options]

force_ratio = None
	#Force output map width/height aspect ratio (overwriting per-projection ratios; not relative to input)
relative_ratio = False
	#scale output map by relative ratios of input and output projections;
	#	if false, output ratio determined purely by output projection
force_scale = None
	#Force output scale; if single value, will be taken as width and height will be scaled to appropriate ratio;
	#	if pair, will be taken as (width,height)
	
truncate_in = True
	#treat input map as truncated to a single world surface or hemisphere
truncate_out = True
	#truncate output map to a single world surface or hemisphere

crop_in = None
	#crop input map to (left, right, top, bottom) pixel indices of given input map, limiting visible area on output
crop_out = None
	#crop output map to (left, right, top, bottom) pixel indices of typical global output map
is_crop_in = None
	#treat input map as having been cropped to these indices; (left, right, top, bottom, full map width, full map height)
	#	the last 2 referring to the size of the original input map
	#   (i.e. use to reproject map after using crop_out or crop_vis, with the first 4 indices being the same)

crop_coords_true = None
	#limit output map to within (min lon, max lon, min lat, max lat) based on given aspect information
crop_coords_in = None
	#limit output map to within (min lon, max lon, min lat, max lat) on input map,
	#	ignoring given aspect and treating as normal aspect (with 0,0 center)
crop_coords_out = None
	#limit output map to within (min lon, max lon, min lat, max lat) on output map, treating as normal aspect
	#   all crop_coords just hide areas and don't change output image size

crop_vis = False
	#crop output to smallest box containing visible areas after all other cropping applied,
	#	and report indices used (for later use of is_crop_in)
	#   otherwise only crop_out actually crops map rather than just hiding areas

graticules = None
	#Add graticules
	#   true : mark true lon/lat based on output aspect
	#   in : mark lon/lat treating input map as normal aspect, ignoring the given input aspect
	#   out : mark lon/lat on output map, treating it as normal aspect
grat_lon = 30
	#list of longitudes to mark with graticules, or single interval between graticules
	#	(starting at antimeridian and proceding east), in degrees
grat_lat = 30
	#as above for latitudes (with interval starting at south pole and proceding north)
grat_color = (100,100,100,50)
	#graticule color in RGBA

[Procedure_configuration]

interp_type = nearest 
	#type of interpolation to apply
	#   none : no interpolation and scipy not required; backward projection only
	#   backward projection supports all scipy interpn methods ('nearest','linear','slinear','cubic''quintic','pchip','spline2fd')
	#   forward projection supports only scipy griddata methods ('nearest','linear','cubic')
proj_direction = backward
	#backward : always project backward (interpolate on input map)
	#   forward : always project forward (interpolate on output map)
	#   avoid_iter : backward by default, but avoid iterative methods if possible
use_sym = True
	#use projection symmetry to speed calculations; appropriate only for global maps
avoid_seam = True
	#use extra steps to avoid seams at edge of original map
tolerance = 0.000001
	#tolerated maximum proportional error on iterative methods
max_iter = 20
	#maximum iterations for iterative methods

[Map_info]

skip_setup = False
	#Skip usual command-line setup and use below info instead

file_in = map.png
	#Input map file name
file_out = map2.png
	#Output map file name
proj_in = Equirectangular
	#Input map projection (name or number in list)
proj_out = Mollweide
	#Output map projection
aspect_in = (0,0,0)
	#Input map aspect (central lon, central lat, rotation from north)
aspect_out = (0,0,0)
	#Output map projection

azim_type_in = global_if
	#global : project azimuthal or conic maps as single global maps
	#   hem : project as single hemispheres
	#   bihem : project as paired hemispheres
	#   global_if : project as global if possible, bihem otherwise
azim_type_out = global_if
	#as above for output
ref_in = None
	#reference values for input proojection (e.g. maximum lat, reference lats)
ref_out = None
	#as above for output
